import { ClientChatSession } from '../model/ClientChatModels'
import { QAMessage } from '../model/QAMessage'
import { ChatMessage } from '../model/ChatModels'
import { StorageManager } from './StorageManager'

export class ClientSessionManager {
  private sessions: ClientChatSession[] = []
  private currentSessionId: string = ''
  private storageManager: StorageManager
  private isInitialized: boolean = false
  private initializationPromise: Promise<void>
  
  constructor() {
    this.storageManager = StorageManager.getInstance()
    this.initializationPromise = this.initializeStorage()
  }
  
  // åˆå§‹åŒ–å­˜å‚¨ç®¡ç†å™¨
  private async initializeStorage() {
    try {
      // è·å–ä¸Šä¸‹æ–‡å¹¶åˆå§‹åŒ–å­˜å‚¨
      const context = this.getContext()
      if (context) {
        await this.storageManager.init(context)
      }
      this.isInitialized = true
      await this.loadSessions()
    } catch (error) {
      console.error('åˆå§‹åŒ–å­˜å‚¨å¤±è´¥:', error)
      // å¦‚æœå­˜å‚¨åˆå§‹åŒ–å¤±è´¥ï¼Œç¨åä¼šåˆ›å»ºé»˜è®¤ä¼šè¯
    }
  }
  
  // è·å–ä¸Šä¸‹æ–‡çš„æ–¹æ³•
  private getContext(): Context | null {
    try {
      // å°è¯•è·å–ä¸Šä¸‹æ–‡
      const context = getContext(this)
      return context as Context
    } catch (error) {
      console.warn('æ— æ³•è·å–ä¸Šä¸‹æ–‡:', error)
      return null
    }
  }
  
  // ä»æŒä¹…åŒ–å­˜å‚¨åŠ è½½ä¼šè¯
  private async loadSessions() {
    if (!this.isInitialized) {
      console.warn('StorageManager not initialized yet')
      return
    }
    
    try {
      // ä»æŒä¹…åŒ–å­˜å‚¨åŠ è½½ä¼šè¯æ•°æ®
      const storedSessions = await this.storageManager.loadSessions()
      const storedCurrentId = await this.storageManager.loadCurrentSessionId()
      
      if (storedSessions && storedSessions.length > 0) {
        this.sessions = storedSessions
      } else {
        // å¦‚æœæ²¡æœ‰æŒä¹…åŒ–æ•°æ®ï¼Œå°è¯•ä»AppStorageåŠ è½½ï¼ˆå‘åå…¼å®¹ï¼‰
        const appStorageSessions: ClientChatSession[] | null | undefined = AppStorage.Get('chatSessions')
        if (appStorageSessions && Array.isArray(appStorageSessions)) {
          this.sessions = appStorageSessions as ClientChatSession[]
          this.sessions.forEach(session => {
            session.createdAt = new Date(session.createdAt)
            session.updatedAt = new Date(session.updatedAt)
          })
        }
      }
      
      if (storedCurrentId) {
        this.currentSessionId = storedCurrentId
      } else {
        // å°è¯•ä»AppStorageåŠ è½½å½“å‰ä¼šè¯ID
        const appStorageCurrentId: string | null | undefined = AppStorage.Get('currentSessionId')
        if (appStorageCurrentId && typeof appStorageCurrentId === 'string') {
          this.currentSessionId = appStorageCurrentId
        }
      }
      
      // å¦‚æœæ²¡æœ‰ä¼šè¯ï¼Œåˆ›å»ºä¸€ä¸ªé»˜è®¤ä¼šè¯
      if (this.sessions.length === 0) {
        // æ³¨æ„ï¼šè¿™é‡Œä¸èƒ½ç›´æ¥awaitï¼Œä¼šå¯¼è‡´å¾ªç¯ä¾èµ–
        // æˆ‘ä»¬å°†åœ¨å¤–é¢å¤„ç†é»˜è®¤ä¼šè¯çš„åˆ›å»º
        console.log('No sessions found, will create default session')
      }
    } catch (error) {
      console.error('åŠ è½½ä¼šè¯å¤±è´¥:', error)
      await this.createSession('æ–°å¯¹è¯')
    }
  }
  
  // ä¿å­˜ä¼šè¯åˆ°æŒä¹…åŒ–å­˜å‚¨
  private async saveSessions() {
    // ä»ç„¶ä¿å­˜åˆ°AppStorageä»¥ä¿æŒå‘åå…¼å®¹
    try {
      AppStorage.Set('chatSessions', this.sessions)
      AppStorage.Set('currentSessionId', this.currentSessionId)
    } catch (error) {
      console.error('ä¿å­˜åˆ°AppStorageå¤±è´¥:', error)
    }
    
    // ä¿å­˜åˆ°æŒä¹…åŒ–å­˜å‚¨
    if (!this.isInitialized) {
      console.warn('StorageManager not initialized, skipping persistent save')
      return
    }
    
    try {
      await this.storageManager.saveSessions(this.sessions)
      await this.storageManager.saveCurrentSessionId(this.currentSessionId)
    } catch (error) {
      console.error('ä¿å­˜åˆ°æŒä¹…åŒ–å­˜å‚¨å¤±è´¥:', error)
    }
  }
  
  // åˆ›å»ºæ–°ä¼šè¯
  async createSession(title: string, bookName?: string): Promise<ClientChatSession> {
    // å¦‚æœæœ‰ä¹¦ç±åç§°ï¼Œä½¿ç”¨ä¹¦ç±åç§°ä½œä¸ºæ ‡é¢˜
    const sessionTitle = bookName ? `ğŸ“š ${bookName}` : title
    const newSession: ClientChatSession = {
      id: this.generateId(),
      title: sessionTitle,
      bookName: bookName,
      messages: [],
      createdAt: new Date(),
      updatedAt: new Date(),
      isActive: true
    }
    
    this.sessions.unshift(newSession)
    this.currentSessionId = newSession.id
    await this.saveSessions()
    
    return newSession
  }
  
  // åˆ‡æ¢ä¼šè¯
  async switchSession(sessionId: string): Promise<boolean> {
    const session = this.sessions.find(s => s.id === sessionId)
    if (session) {
      this.currentSessionId = sessionId
      await this.saveSessions()
      return true
    }
    return false
  }
  
  // åˆ é™¤ä¼šè¯
  async deleteSession(sessionId: string): Promise<boolean> {
    const index = this.sessions.findIndex(s => s.id === sessionId)
    if (index !== -1) {
      this.sessions.splice(index, 1)
      
      // å¦‚æœåˆ é™¤çš„æ˜¯å½“å‰ä¼šè¯ï¼Œåˆ‡æ¢åˆ°ç¬¬ä¸€ä¸ªä¼šè¯
      if (sessionId === this.currentSessionId) {
        if (this.sessions.length > 0) {
          this.currentSessionId = this.sessions[0].id
        } else {
          await this.createSession('æ–°å¯¹è¯')
        }
      }
      
      await this.saveSessions()
      return true
    }
    return false
  }
  
  // è·å–å½“å‰ä¼šè¯
  getCurrentSession(): ClientChatSession | null {
    return this.sessions.find(s => s.id === this.currentSessionId) || null
  }
  
  // è·å–æ‰€æœ‰ä¼šè¯
  getAllSessions(): ClientChatSession[] {
    return this.sessions
  }
  
  // æ·»åŠ æ¶ˆæ¯åˆ°å½“å‰ä¼šè¯
  async addMessageToCurrentSession(message: QAMessage): Promise<void> {
    const currentSession = this.getCurrentSession()
    if (currentSession) {
      currentSession.messages.push(message)
      currentSession.updatedAt = new Date()
      await this.saveSessions()
    }
  }
  
  // æ¸…ç©ºå½“å‰ä¼šè¯æ¶ˆæ¯
  async clearCurrentSessionMessages(): Promise<void> {
    const currentSession = this.getCurrentSession()
    if (currentSession) {
      currentSession.messages = []
      currentSession.updatedAt = new Date()
      await this.saveSessions()
    }
  }
  
  // æ›´æ–°ä¼šè¯ä¹¦ç±ä¿¡æ¯
  async updateCurrentSessionBookInfo(bookName: string, bookInfo: Object): Promise<void> {
    const currentSession = this.getCurrentSession()
    if (currentSession) {
      currentSession.bookName = bookName
      currentSession.bookInfo = bookInfo
      // ä½¿ç”¨ä¹¦ç±åç§°ä½œä¸ºä¼šè¯æ ‡é¢˜
      currentSession.title = `ğŸ“š ${bookName}`
      currentSession.updatedAt = new Date()
      await this.saveSessions()
    }
  }

  async clearCurrentSessionBookInfo(): Promise<void> {
    const currentSession = this.getCurrentSession()
    if (currentSession) {
      currentSession.bookName = undefined
      currentSession.bookInfo = undefined
      // Optionally reset title if it was based on the book name
      if (currentSession.title.startsWith('ğŸ“š')) {
        currentSession.title = 'æ–°å¯¹è¯'
      }
      currentSession.updatedAt = new Date()
      await this.saveSessions()
    }
  }

  
  // è·å–ç”¨äºAPIçš„èŠå¤©å†å²
  getChatHistoryForAPI(sessionId: string): ChatMessage[] {
    const session = this.sessions.find(s => s.id === sessionId)
    if (!session) {
      return []
    }
    
    return session.messages.map((msg: QAMessage): ChatMessage => ({
      role: msg.type === 'question' ? 'user' : 'assistant',
      content: msg.content
    }))
  }
  
  // è·å–å½“å‰ä¼šè¯çš„èŠå¤©å†å²
  getCurrentChatHistoryForAPI(): ChatMessage[] {
    return this.getChatHistoryForAPI(this.currentSessionId)
  }
  
  // ç¡®ä¿åˆå§‹åŒ–å®Œæˆ
  async ensureInitialized(): Promise<void> {
    await this.initializationPromise
  }
  
  // æ£€æŸ¥æ˜¯å¦éœ€è¦åˆ›å»ºé»˜è®¤ä¼šè¯
  async ensureDefaultSession(): Promise<void> {
    if (this.sessions.length === 0) {
      await this.createSession('æ–°å¯¹è¯')
    }
  }
  
  // ç”ŸæˆID
  private generateId(): string {
    return Date.now().toString(36) + Math.random().toString(36).substr(2)
  }
  
  // è·å–ä¼šè¯ç»Ÿè®¡
  getSessionStats(): SessionStats {
    const totalMessages = this.sessions.reduce((sum: number, session: ClientChatSession) => sum + session.messages.length, 0)
    return {
      total: this.sessions.length,
      totalMessages: totalMessages
    }
  }
}

export interface SessionStats {
  total: number
  totalMessages: number
}