import { BookInfo, BookInfoData } from '../model/BookInfo'
import { QAMessage } from '../model/QAMessage'
import { ChatRequest, ChatMessage as ChatMessageModel } from '../model/ChatModels'
import { ClientChatSession } from '../model/ClientChatModels'
import { ApiService } from '../services/ApiService'
import { ClientSessionManager } from '../services/ClientSessionManager'
import { QAComponent } from '../components/QAComponent'
import { LoadingComponent } from '../components/LoadingComponent'
import { SessionListComponent } from '../components/SessionListComponent'
import { PromptSuggestion } from '../model/Prompt'
import { PromptService } from '../services/PromptService'
import { PromptSuggestions } from '../components/PromptSuggestions'

@Entry
@Component
struct Index {
  @State bookInfo: BookInfo | null = null
  @State isLoading: boolean = false
  @State messages: QAMessage[] = []
  @State currentInput: string = ''
  @State sessions: ClientChatSession[] = []
  @State currentSessionId: string = ''
  @State showSessionList: boolean = false
  @State showPromptSuggestions: boolean = false
  private promptSuggestions: PromptSuggestion[] = []
  
  private sessionManager: ClientSessionManager = new ClientSessionManager()
  private scroller: Scroller = new Scroller()
  private textInputController: TextInputController = new TextInputController()

  async aboutToAppear() {
    try {
      // ç­‰å¾…ä¼šè¯ç®¡ç†å™¨åˆå§‹åŒ–å®Œæˆ
      await this.sessionManager.ensureInitialized()
      // ç¡®ä¿æœ‰é»˜è®¤ä¼šè¯
      await this.sessionManager.ensureDefaultSession()
      // æ›´æ–°ç•Œé¢
      this.updateSessionsFromManager()
      this.loadCurrentSession()
    } catch (error) {
      console.error('Failed to initialize session manager:', error)
    }
  }

  updateSessionsFromManager() {
    this.sessions = this.sessionManager.getAllSessions()
    this.currentSessionId = this.sessionManager.getCurrentSession()?.id || ''
  }

  loadCurrentSession() {
    const currentSession = this.sessionManager.getCurrentSession()
    if (currentSession) {
      this.messages = currentSession.messages
      this.bookInfo = currentSession.bookName ? new BookInfo(currentSession.bookInfo as BookInfoData) : null
    } else {
      this.messages = []
      this.bookInfo = null
    }
  }

  async createNewSession(title?: string, bookName?: string) {
    const sessionTitle = title || 'æ–°å¯¹è¯'
    const session = await this.sessionManager.createSession(sessionTitle, bookName)

    this.updateSessionsFromManager()
    this.loadCurrentSession()
    this.showPromptSuggestions = false
    this.showSessionList = false

    return session
  }

  async switchSession(session: ClientChatSession) {
    await this.sessionManager.switchSession(session.id)
    this.updateSessionsFromManager()
    this.loadCurrentSession()
    this.showSessionList = false

    // åˆ‡æ¢ä¼šè¯åï¼Œåˆ¤æ–­æ˜¯å¦æ˜¾ç¤ºæ¨èé—®é¢˜
    // åªè¦æœ‰ä¹¦æœ¬ä¿¡æ¯ï¼Œå¹¶ä¸”è‡³å°‘æœ‰è¿‡ä¸€ä¸ªé—®é¢˜ï¼ˆå³ä¹¦åæŸ¥è¯¢ï¼‰ï¼Œå°±æ˜¾ç¤ºæ¨è
    const userQuestions = this.messages.filter(m => m.type === 'question').length
    if (this.bookInfo && userQuestions >= 1) {
      this.promptSuggestions = PromptService.getBookAnalysisPrompts()
      this.showPromptSuggestions = true
    } else {
      this.showPromptSuggestions = false
    }

    // æ»šåŠ¨åˆ°åº•éƒ¨
    setTimeout(() => {
      this.scroller.scrollEdge(Edge.Bottom)
    }, 100)
  }

  async deleteSession(sessionId: string) {
    await this.sessionManager.deleteSession(sessionId)
    this.updateSessionsFromManager()
    this.loadCurrentSession()
  }

  async processMessage() {
    if (!this.currentInput.trim()) {
      return
    }

    this.showPromptSuggestions = false // ç”¨æˆ·å‘é€æ–°æ¶ˆæ¯æ—¶ï¼Œéšè—æ¨è
    const input = this.currentInput.trim()
    this.currentInput = ''

    // æ·»åŠ ç”¨æˆ·æ¶ˆæ¯åˆ°ä¼šè¯ç®¡ç†å™¨
    const userMessage = new QAMessage(input, 'question')
    await this.sessionManager.addMessageToCurrentSession(userMessage)
    this.loadCurrentSession() // é‡æ–°åŠ è½½æ¶ˆæ¯ä»¥åŒæ­¥ç•Œé¢
    this.isLoading = true

    try {
      if (!this.bookInfo) {
        // First, get the complete BookInfo object from the API
        const fullBookInfo = await ApiService.getBookInfo(input)

        if (fullBookInfo.is_found) {
          // Book was found, proceed as before
          this.bookInfo = fullBookInfo

          // Update session with the found book info
          await this.sessionManager.updateCurrentSessionBookInfo(this.bookInfo.title, this.bookInfo)

          // Add book details to the chat
          const bookInfoText = `ğŸ“š ã€Š${this.bookInfo.title}ã€‹\n\n` +
            `ä½œè€…ï¼š${this.bookInfo.author || 'æœªçŸ¥'}\n` +
            `å‡ºç‰ˆç¤¾ï¼š${this.bookInfo.publisher || 'æœªçŸ¥'}\n` +
            `å‡ºç‰ˆå¹´ä»½ï¼š${this.bookInfo.year || 'æœªçŸ¥'}\n\n` +
            `ç®€ä»‹ï¼š\n${this.bookInfo.description || 'æš‚æ— ç®€ä»‹'}`
          const bookInfoMessage = new QAMessage(bookInfoText, 'answer')
          await this.sessionManager.addMessageToCurrentSession(bookInfoMessage)
          
        } else {
          // Book was not found, display the reason
          this.bookInfo = null // Ensure no book info is displayed
          await this.sessionManager.clearCurrentSessionBookInfo()
          
          const notFoundMessage = new QAMessage(fullBookInfo.not_found_reason, 'answer')
          await this.sessionManager.addMessageToCurrentSession(notFoundMessage)
        }
        
        this.loadCurrentSession() // Reload session to show new messages

      } else {
        // åç»­é—®ç­”ï¼šä½¿ç”¨æ–°çš„æ— çŠ¶æ€API
        const chatHistory = this.sessionManager.getCurrentChatHistoryForAPI()
        const answer = await ApiService.chatWithHistory({
          bookName: this.bookInfo.title,
          messages: chatHistory,
          question: input
        })

        const answerMessage = new QAMessage(answer, 'answer')
        await this.sessionManager.addMessageToCurrentSession(answerMessage)
        this.loadCurrentSession() // é‡æ–°åŠ è½½æ¶ˆæ¯ä»¥åŒæ­¥ç•Œé¢
      }
    } catch (error) {
      // When book info fails, the raw LLM response is in error.message.
      // We display it directly.
      const errorMessage = new QAMessage(error.message, 'answer')
      // Ensure bookInfo is null so we don't show prompts or old info.
      this.bookInfo = null
      await this.sessionManager.clearCurrentSessionBookInfo()
      await this.sessionManager.addMessageToCurrentSession(errorMessage)
      this.loadCurrentSession() // é‡æ–°åŠ è½½æ¶ˆæ¯ä»¥åŒæ­¥ç•Œé¢
    } finally {
      this.isLoading = false
      // æ›´æ–°ä¼šè¯åˆ—è¡¨
      this.updateSessionsFromManager()

      // å¦‚æœæœ‰ä¹¦ç±ä¿¡æ¯ï¼Œåˆ™åœ¨æ¯æ¬¡å›ç­”åé‡æ–°æ˜¾ç¤ºæ¨èé—®é¢˜
      if (this.bookInfo) {
        this.promptSuggestions = PromptService.getBookAnalysisPrompts()
        this.showPromptSuggestions = true
      }

      // å»¶è¿Ÿæ»šåŠ¨åˆ°åº•éƒ¨ï¼Œç¡®ä¿å†…å®¹å·²æ¸²æŸ“
      setTimeout(() => {
        this.scroller.scrollEdge(Edge.Bottom)
      }, 100)
    }
  }

  build() {
    Stack() {
      // ä¸»ç•Œé¢
      Column() {
        // é¡¶éƒ¨æ ‡é¢˜æ 
        Row() {
          // å·¦ä¾§ä¼šè¯åˆ—è¡¨å›¾æ ‡æŒ‰é’®
          Button() {
            Image($r('app.media.startIcon'))
              .width(20)
              .height(20)
          }
          .width(32)
          .height(32)
          .backgroundColor('#f0f0f0')
          .onClick(() => {
            this.showSessionList = !this.showSessionList
          })
          
          Text('AIè¯»ä¹¦åŠ©æ‰‹')
            .fontSize(20)
            .fontWeight(FontWeight.Bold)
            .layoutWeight(1)
            .textAlign(TextAlign.Center)
          
          // å³ä¾§æ–°å»ºä¼šè¯æŒ‰é’®
          Button() {
            Text('+')
              .fontSize(20)
              .fontWeight(FontWeight.Bold)
              .fontColor('#ffffff')
          }
          .width(32)
          .height(32)
          .backgroundColor('#007aff')
          .borderRadius(16)
          .onClick(async () => {
            await this.createNewSession()
          })
        }
        .width('100%')
        .margin({ bottom: 16 })
        
        // å½“å‰ä¼šè¯ä¿¡æ¯
        if (this.currentSessionId) {
          Row() {
            Text(this.getCurrentSessionTitle())
              .fontSize(14)
              .fontColor('#666')
              .maxLines(1)
              .textOverflow({ overflow: TextOverflow.Ellipsis })
              .layoutWeight(1)
            
          }
          .width('100%')
          .margin({ bottom: 12 })
          .padding({ left: 8, right: 8 })
        }
        
        // èŠå¤©å†…å®¹åŒºåŸŸ
        Scroll(this.scroller) {
          Column() {
            ForEach(this.messages, (message: QAMessage) => {
              QAComponent({ message: message })
            })
          }
          .width('100%')
          .padding({ left: 12, right: 12 })
        }
        .layoutWeight(1)
        .width('100%')
        .scrollBar(BarState.Off)
        .align(Alignment.Top)
        
        // åº•éƒ¨åŠ è½½çŠ¶æ€
        if (this.isLoading) {
          LoadingComponent()
            .margin({ bottom: 8 })
        }

        // æ¨èé—®é¢˜åŒºåŸŸ
        if (this.showPromptSuggestions && this.bookInfo) {
          PromptSuggestions({
            suggestions: this.promptSuggestions,
            onSuggestionClick: (suggestion: PromptSuggestion) => {
              this.handleSuggestionClick(suggestion)
            }
          })
        }
        
        // åº•éƒ¨è¾“å…¥åŒºåŸŸ
        Row() {
          TextInput({ 
            placeholder: this.bookInfo ? 'è¯·è¾“å…¥å…³äºè¿™æœ¬ä¹¦çš„é—®é¢˜' : 'è¯·è¾“å…¥ä¹¦ç±åç§°å¼€å§‹å¯¹è¯',
            controller: this.textInputController,
            text: this.currentInput
          })
            .layoutWeight(1)
            .height(40)
            .margin({ right: 10 })
            .enabled(!this.isLoading)
            .onChange((value: string) => {
              this.currentInput = value
            })
          
          Button('å‘é€')
            .width(80)
            .height(40)
            .enabled(!this.isLoading && this.currentInput.trim().length > 0)
            .onClick(() => {
              this.processMessage()
            })
        }
        .width('100%')
        .margin({ top: 8, bottom: 20 })
      }
      .padding(20)
      .width('100%')
      .height('100%')
      
      // ä¼šè¯åˆ—è¡¨ä¾§è¾¹æ 
      if (this.showSessionList) {
        Row() {
          // ä¼šè¯åˆ—è¡¨ï¼ˆå·¦ä¾§ï¼‰
          Column() {
            SessionListComponent({
              sessions: this.sessions,
              currentSessionId: this.currentSessionId,
              isLoading: false,
              onSessionSelect: async (session: ClientChatSession) => {
                await this.switchSession(session)
              },
              onSessionDelete: async (sessionId: string) => {
                await this.deleteSession(sessionId)
              },
              onNewSession: async () => {
                await this.createNewSession()
              }
            })
          }
          .width('80%')
          .height('100%')
          .backgroundColor('#fff')
          .shadow({
            radius: 10,
            color: 'rgba(0,0,0,0.1)',
            offsetX: 2,
            offsetY: 0
          })
          
          // é®ç½©å±‚
          Blank()
            .layoutWeight(1)
            .backgroundColor('rgba(0,0,0,0.3)')
            .onClick(() => {
              this.showSessionList = false
            })
        }
        .width('100%')
        .height('100%')
      }
    }
    .width('100%')
    .height('100%')
  }
  
  private getCurrentSessionTitle(): string {
    if (!this.currentSessionId) {
      return 'æ–°å¯¹è¯'
    }
    
    const session = this.sessions.find(s => s.id === this.currentSessionId)
    return session ? session.title : 'æœªçŸ¥ä¼šè¯'
  }

  async handleSuggestionClick(suggestion: PromptSuggestion) {
    this.currentInput = suggestion.prompt;
    await this.processMessage();
  }
}